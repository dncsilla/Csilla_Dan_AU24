--PART 1--------------------------------------------------------------------------------------------------------------------------------
/*1.	All animation movies released between 2017 and 2019 with rate more than 1, alphabetical
 Interpetation: "rate more than 1" refers to the rental rate. 
 The query aims to retrieve the titles of all animation films released between the years 2017 and 2019,
 that have a rental rate greater than 1. The results are displayed in alphabetical order by the title.
 The query pulls data from the film, film_category, and category tables, which contain information on movies, 
 their categories, and rental attributes. By joining film_category with category, we ensure that only movies categorized as "Animation"
 are included in the results, which also limits the dataset specifically to films in the Animation genre.
 The query further restricts the results to animation movies released between 2017 and 2019 and also filters out films with a 
 rental rate of 1 or lower, including only those that have a rental rate higher than 1. 

     
V1 Using subqueries
##COMMENTS:when working with text data please use UPPER or LOWER function to make sure the text case doesn't affect the output. 
            For SQL Animation, ANIMATION and animation are 3 different values.
            please don't leave empty rows inside the single query. Usually, such rows are treated by the system as the end of the script, 
            so if you don't manually select the whole script before you run it, it will fail to execute.
            please always put ; after each separate script.
            please follow the coding standards: indents, upper case for SQL commands. --Updated */
SELECT f.title
FROM film f
WHERE f.release_year BETWEEN 2017 AND 2019  --- restricting movies released between 2017 and 2019
  AND f.rental_rate > 1 --- filtering OUT films with a rental rate of 1 or lower
  AND f.film_id IN (
				      SELECT fc.film_id
				      FROM film_category fc
				      WHERE fc.category_id = (
									          SELECT c.category_id
									          FROM category c
									          WHERE UPPER(c.name) = UPPER('Animation')
									      ))								
ORDER BY f.title;
---V2 using joins
SELECT f.title
FROM film f
INNER JOIN film_category fc ON f.film_id = fc.film_id
INNER JOIN category c ON fc.category_id = c.category_id
WHERE UPPER(c.name) = UPPER('Animation')
  AND f.release_year BETWEEN 2017 AND 2019
  AND f.rental_rate > 1
ORDER BY f.title;


/*2.The revenue earned by each rental store since March 2017 (columns: address and address2 – as one column, revenue)
Interpetation: Assuming revenue is realised on payment date, can be also on the date of the rental in some cases.
 This query calculates and lists the total revenue generated by each store, identified by its location (city and country), 
 for transactions made on or after March 1, 2017. The SELECT clause combines the city and country names into a single column (store), 
 providing a readable identifier for each store location in the format "City, Country."*/
-- V1: Using joins
SELECT (c.city || ', '::text) || cy.country AS store, --concatenating cities AND countries
    SUM(p.amount) AS revenue
FROM payment p
JOIN rental r ON p.rental_id = r.rental_id
JOIN inventory i ON r.inventory_id = i.inventory_id
JOIN store s ON i.store_id = s.store_id
JOIN address a ON s.address_id = a.address_id
JOIN city c ON a.city_id = c.city_id
JOIN country cy ON c.country_id = cy.country_id
WHERE payment_date >= '2017-03-01' -- assuming revenue is realised on payment date
GROUP BY cy.country, c.city, s.store_id
ORDER BY store; 
 --V2 Using CTE
 WITH StoreRevenue AS (
						SELECT s.store_id,
								(c.city || ', ' || cy.country) AS store, --concatenating cities AND countries
						        SUM(p.amount) AS revenue
						FROM payment p
						INNER JOIN rental r ON p.rental_id = r.rental_id
						INNER JOIN inventory i ON r.inventory_id = i.inventory_id
						INNER JOIN store s ON i.store_id = s.store_id
						INNER JOIN address a ON s.address_id = a.address_id
						INNER JOIN city c ON a.city_id = c.city_id
						INNER JOIN country cy ON c.country_id = cy.country_id
						WHERE p.payment_date >= '2017-03-01'  
						GROUP BY s.store_id, c.city, cy.country
						)
SELECT store, revenue
FROM StoreRevenue
ORDER BY store;
/*3.Top-5 actors by number of movies (released since 2015) they took part in (columns: first_name, last_name, number_of_movies, 
  sorted by number_of_movies in descending order)
-Interpetation : The primary goal is to identify the top five actors who have been actively participating in films since 2015.
The data comes from two primary tables and one junction table:
actor table: Contains details about each actor, such as their first and last names.
film table: Contains information about films, including their release years.
film_actor table: Acts as a junction table connecting actors with the films they have appeared in, 
which allows us to track each actor’s filmography.
By connecting these tables, we can extract relevant details about each actor and the films they have acted in.
Note: We might want to  specify our ordering further (such as we should take account for the first name or last name in alphabetical 
order)as there are more values with the same number of movies, exceeding the top 5.*/

-- V1: using subqueries
SELECT a.first_name, 
	a.last_name, 
	(SELECT count(*) 
	FROM film_actor fa
	INNER JOIN film f ON fa.film_id = f.film_id
	WHERE fa.actor_id = a.actor_id AND f.release_year >= 2015 --Filtering based ON RELEASE YEAR INCLUDING 2015 onwards AND Connecting the OUTER AND INNER query based ON actor_id
	) AS number_of_movies
FROM  actor a                                                 
ORDER BY  number_of_movies DESC
LIMIT (5);
 
-- V2: using joins						 					 
SELECT a.first_name, 
	a.last_name, 
	count(*) as number_of_movies
FROM  actor a 
INNER JOIN film_actor fa ON a.actor_id = fa.actor_id 
INNER JOIN film f ON fa.film_id=f.film_id 
WHERE f.release_year >= '2015'
GROUP BY a.first_name, a.last_name
ORDER BY number_of_movies DESC
LIMIT (5);
 
 
/*4.Number of Drama, Travel, Documentary per year (columns: release_year, number_of_drama_movies, number_of_travel_movies, 
  number_of_documentary_movies), sorted by release year in descending order. Dealing with NULL values is encouraged)
Interpetation: Preparing a report on movie counts for Drama, Travel, and Documentary categories each year, 
while handling cases with no data for a category in a given year by using COALESCE to display 0. In a sence, 
we have to create subqueries for each category and then connect it to the main query.
 V1 : Using CTE
 ###COMMENT : part 1 task 4 v1: it's not efficient to use subqueries to select data from categorycounts CTE inside the main query 
 selecting data from the same CTE.Try to optimize this script (CASE function can help here).*/

WITH CategoryCounts AS (
    SELECT f.release_year,c."name",
        COUNT(f.film_id) AS movie_count
    FROM film f
    INNER JOIN film_category fc ON f.film_id = fc.film_id
    INNER JOIN category c ON fc.category_id = c.category_id
    WHERE c."name" IN ('Drama','Travel','Documentary')  -- Using IN as filtering for multiple values:'Drama', 'Travel', and 'Documentary' categories
    GROUP BY f.release_year, c.category_id
	)
SELECT 
    cc.release_year,
    COALESCE(SUM(CASE WHEN cc."name" = 'Drama' THEN cc.movie_count END), 0) AS number_of_drama_movies, -- calculates the total count of 'Drama' movies for each release year; uses COALESCE to replace NULLs with 0
    COALESCE(SUM(CASE WHEN cc."name" = 'Travel' THEN cc.movie_count END), 0) AS number_of_travel_movies, -- calculates the total count of 'Travel' movies for each release year; uses COALESCE to replace NULLs with 0
    COALESCE(SUM(CASE WHEN cc."name" = 'Documentary' THEN cc.movie_count END), 0) AS number_of_documentary_movies -- calculates the total count of 'Documentary' movies for each release year; uses COALESCE to replace NULLs with 0
FROM CategoryCounts cc
GROUP BY cc.release_year
ORDER BY cc.release_year DESC;   
--V2: Using subqueries
SELECT 
    f.release_year,
    -- Subquery for counting Drama movies
    (SELECT COALESCE(COUNT(f_d.film_id), 0) -- Counts Drama movies and replaces NULL with 0 if no results
     FROM film f_d
     INNER JOIN film_category fc_d ON f_d.film_id = fc_d.film_id
     INNER JOIN category c_d ON fc_d.category_id = c_d.category_id
     WHERE f_d.release_year = f.release_year AND c_d."name" = 'Drama'
    ) AS number_of_drama_movies,
    -- Subquery for counting Travel movies
    (SELECT COALESCE(COUNT(f_t.film_id), 0) -- Counts Travel movies and replaces NULL with 0 if no results
     FROM film f_t
     INNER JOIN film_category fc_t ON f_t.film_id = fc_t.film_id
     INNER JOIN category c_t ON fc_t.category_id = c_t.category_id
     WHERE f_t.release_year = f.release_year AND c_t."name" = 'Travel'
    ) AS number_of_travel_movies,
    -- Subquery for counting Documentary movies
    (SELECT COALESCE(COUNT(f_doc.film_id), 0) -- Counts Documentary movies and replaces NULL with 0 if no results
     FROM film f_doc
     INNER JOIN film_category fc_doc ON f_doc.film_id = fc_doc.film_id
     INNER JOIN category c_doc ON fc_doc.category_id = c_doc.category_id
     WHERE f_doc.release_year = f.release_year AND c_doc."name" = 'Documentary'
    ) AS number_of_documentary_movies
FROM film f
GROUP BY f.release_year
ORDER BY f.release_year DESC;


/*5.For each client, display a list of horrors that he had ever rented (in one column, separated by commas), 
  and the amount of money that he paid for it.
 Interpetation: The main query selects each customer’s customer_id, as well as their first_name and last_name concatenated 
 as customer_name. Two subqueries needed for completing the task- one for the rented horror movies and one for the total amount paid.
 The rented horror movies shows all horror movies rented by customers and subquery joins film, film_category, inventory, 
 and rental tables to filter horror films rented by each customer, 
 then uses STRING_AGG to concatenate all the horror movie titles the customer rented, separated by commas.
 The total amount paid calculates the total amount each customer spent on horror rentals.
 It joins payment, rental, inventory, and film_category tables to identify the horror movie rentals for each customer 
 and sums the amount paid for those rentals.
 The final report includes the customer’s name, a comma-separated list of horror movies they rented (rented_horror_movies), 
 and the total amount they spent on horror rentals (total_amount_paid).
  
 ### COMMENT: part 1 task 5: if not requested ids are not included in the output - this is a kind of technical data that usually 
              doesn't bring any value to the output. Same for part 2 task 6. --updated 
 ### COMMENT: part 1 task 5 v1: same result can be achieved without subqueries.--updated*/
--V1: Using CTE  
WITH Horrorrentals AS (            --Creating CTE for rentals, of which has a horror category
	SELECT c.customer_id,c.first_name,c.last_name, f.title
	AS horror_movies, p.amount
	FROM customer c 
	INNER JOIN rental r ON c.customer_id =r.customer_id
	INNER JOIN payment p ON p.rental_id = r.rental_id
	INNER JOIN inventory i ON i.inventory_id = r.inventory_id 
	INNER JOIN film_category fc ON fc.film_id = i.film_id 
	INNER JOIN film f ON f.film_id = fc.film_id 
	INNER JOIN category ca ON ca.category_id = fc.category_id
	WHERE ca."name" = 'Horror')       -- Filtering FOR Horror movies
SELECT (hr.first_name || ' ' || hr.last_name) AS customer_name,
    STRING_AGG(hr.horror_movies, ', ') AS rented_horror_movies,  -- Concatenating movie titles directly FROM cte
    SUM(hr.amount) AS total_amount_paid  -- summing the amount directly FROM cte
FROM HorrorRentals hr
GROUP BY hr.customer_id, customer_name
ORDER BY customer_name;

/*V2: Using subqueries ---
The difference in behavior between the v1 and v2 queries lies in how each one processes and aggregates rental data. 
The V1 query (using the CTE HorrorRentals) avoids NULL values because it explicitly filters the data within the CTE, 
ensuring that only customers who have rented horror movies are included in the final results. 
The V2 query includes all customers, regardless of whether they rented a horror movie or not, which results 
in NULL values for customers with no relevant rentals or payments, therefore for handling these null values, 
we have to change the WHERE clause in the outer query filtering based on the rows, in which rented_horror_movies or total_amount_paid 
is NULL after computing their value.

### COMMENT: part 1 task 5 v2: try to solve it with one subquery. Currently all subqueries use same tables, JOINs and filters which 
          makes the system do same calculations for several times which negatively affects the performance of the query.--updated*/

SELECT 
    (c.first_name || ' ' || c.last_name) AS customer_name, -- Concatenates first and last name to create a full customer name
    COALESCE(rented_horror.rented_horror_movies, '') AS rented_horror_movies, -- If no horror movies were rented, returns an empty string
    COALESCE(rented_horror.total_amount_paid, 0) AS total_amount_paid -- If no amount was paid for horror rentals, returns 0
FROM customer c
INNER JOIN (                                              -- INNER joining the subquery TO the customers table
    SELECT                                                 -- subquery to aggregate rented horror movies and calculate total amount paid per customer
        r.customer_id,
        STRING_AGG(f.title, ', ') AS rented_horror_movies, -- Concatenates horror movie titles separated by commas for each customer
        COALESCE(SUM(p.amount), 0) AS total_amount_paid    -- Sums up the total amount paid by each customer, defaulting to 0 if no payments are found
    FROM rental r
    INNER JOIN inventory i ON r.inventory_id = i.inventory_id
    INNER JOIN film_category fc ON i.film_id = fc.film_id
    INNER JOIN film f ON f.film_id = fc.film_id
    INNER JOIN category ca ON ca.category_id = fc.category_id
    INNER JOIN payment p ON p.rental_id = r.rental_id
    WHERE ca."name" = 'Horror'
    GROUP BY r.customer_id
) AS rented_horror ON rented_horror.customer_id = c.customer_id
ORDER BY customer_name;

/* PART 2------------------------------------------------------------------------------------------------------------------------------------
 6. Which three employees generated the most revenue in 2017? They should be awarded a bonus for their outstanding performance. 
Assumptions: 
staff could work in several stores in a year, please indicate which store the staff worked in (the last one);
if staff processed the payment then he works in the same store; 
take into account only payment_date

 Interpetation: We do not want to filter the data by stores the staff worked in, only showing the latest stores they worked in 2017
 and the total revenue the each staff generated in 2017. In case we would want to filter based on the latest store the staff worked in, 
 we would extend the where caluse similarly to the subquery in the select main query.

 Hanna Carry, Hanna Rainbow and Peter Lockyard  generated the most revenue in 2017.*/

--V1:

SELECT s.first_name, 
	s.last_name, 
    sum(p.amount) AS generated_revenue,
    (SELECT  s2.store_id
	FROM staff s2 
	INNER JOIN payment p2 ON p2.staff_id = s2.staff_id
	WHERE s2.staff_id = p.staff_id               -- Need TO JOIN INNER query TO main query
		AND EXTRACT(YEAR FROM p2.payment_date) = 2017 -- Filtering the payment date for 2017
	ORDER BY p2.payment_date DESC
	Limit(1)                                      -- Finding the latest store
	) AS last_store_id					
FROM payment p
INNER JOIN staff s ON s.staff_id = p.staff_id 
WHERE EXTRACT(YEAR FROM p.payment_date) = 2017   -- Filtering the payment date for 2017
GROUP BY p.staff_id, s.first_name, s.last_name
ORDER BY generated_revenue DESC
LIMIT (3); ---top 3 employee

--V2:

/*###COMMENT:part 2 task 6 v2: please rewrite the query without a subquery - with just CTE. 
          Also, last_store_id is not a CTE as mentioned in the comments, it is a subquery. --Updated */

WITH StaffRevenue AS (                              -- CTE to calculate the total revenue generated by each staff member in 2017
    SELECT p.staff_id, s.first_name, s.last_name,
        SUM(p.amount) AS generated_revenue
    FROM payment p
    INNER JOIN staff s 
    ON s.staff_id = p.staff_id
    WHERE EXTRACT(YEAR FROM p.payment_date) = 2017  -- Filtering the payment date for 2017
    GROUP BY p.staff_id, s.first_name, s.last_name
	),
LastPayment AS (                                    -- CTE to identify the last payment date and associated store for each staff member in 2017
    SELECT 
        s.staff_id, 
        s.store_id,
        MAX(p.payment_date) AS last_payment_date
    FROM staff s
    INNER JOIN payment p ON p.staff_id = s.staff_id
    WHERE EXTRACT(YEAR FROM p.payment_date) = 2017  -- Filtering for payments in 2017
    GROUP BY s.staff_id, s.store_id
)
SELECT sr.first_name,                               -- Main query to select top staff members by revenue and their last store location
       sr.last_name, 
       sr.generated_revenue,
       lp.store_id AS last_store_id                  --  Retrieving the store ID of the last payment made in 2017
FROM StaffRevenue sr
JOIN LastPayment lp ON sr.staff_id = lp.staff_id
WHERE lp.last_payment_date = (                      -- USING =, because max returns a single value	
    SELECT MAX(lp2.last_payment_date)               -- Ensures only the latest payment record is retrieved if multiple stores exist
    FROM LastPayment lp2
    WHERE lp2.staff_id = sr.staff_id)	
ORDER BY sr.generated_revenue DESC
LIMIT 3;
/*7. Which 5 movies were rented more than others (number of rentals), and what's the expected age of the audience for these movies? 
To determine expected age please use 'Motion Picture Association film rating system

Interpetation:The query retrieves the titles of films along with the count of their rentals and the expected audience age based
 on their Motion Picture Association film rating system ratings. The rental counts are calculated using subqueries to look up 
 the inventory and rental records, ensuring that no ungrouped columns from the outer query are improperly referenced.
 The result is ordered by the number of rentals in descending order, limited to the top five films.

 Note: We ight want to specify our ordering further (such as we should take account title in alphabetical order or expected audinence age) 
 as there are more values with the same number of rentals, exceeding the top 5.*/

--V1
SELECT f.title, count(r.rental_id) AS number_of_rentals,
CASE f.rating                                            -- USING CASE ..WHEN FOR applying different expressions or values based on specific conditions
        WHEN 'G' THEN 'All ages'
        WHEN 'PG' THEN '10+'
        WHEN 'PG-13' THEN '13+'
        WHEN 'R' THEN '17+'
        WHEN 'NC-17' THEN '18+'
        ELSE 'Unknown age rating'
        END AS expected_audience_age
FROM rental r
INNER JOIN inventory i 
ON i.inventory_id = r.inventory_id 
INNER JOIN film f 
ON f.film_id = i.film_id 
GROUP BY f.title, f.rating 
ORDER BY number_of_rentals DESC
LIMIT(5);

--V2: Using CTE, which calculates the number of rentals

WITH RentalCounts AS (
    SELECT 
        f.title,
        COUNT(r.rental_id) AS number_of_rentals,
        f.rating
    FROM rental r
    INNER JOIN inventory i ON i.inventory_id = r.inventory_id 
    INNER JOIN film f ON f.film_id = i.film_id 
    GROUP BY f.title, f.rating)
SELECT 
    rc.title,
    rc.number_of_rentals,
    CASE rc.rating                            -- USING CASE ..WHEN FOR applying different expressions or values based on specific conditions
        WHEN 'G' THEN 'All ages'
        WHEN 'PG' THEN '10+'
        WHEN 'PG-13' THEN '13+'
        WHEN 'R' THEN '17+'
        WHEN 'NC-17' THEN '18+'
        ELSE 'Unknown age rating'
    END AS expected_audience_age
FROM RentalCounts rc
ORDER BY rc.number_of_rentals DESC
LIMIT 5;


   
/*Part 3. Which actors/actresses didn't act for a longer period of time than the others? 
The task can be interpreted in various ways, and here are a few options:
V1: gap between the latest release_year and current year per each actor;
V2: gaps between sequential films per each actor;
It would be plus if you could provide a solution for each interpretation

 Selected the V1 interpetation of the task.: 
 The query retrieves a list of the top five actors who have had the longest gaps since their most recent movie release. 
 For each actor, it provides their first name, last name, the release year of their latest movie, 
 and the number of years since that release.*/

SELECT a.first_name, a.last_name,
 MAX(f.release_year) AS latest_movie_year,
 EXTRACT (year FROM current_date) - MAX(f.release_year) AS gap_since_last_movie	-- calculating the difference BETWEEN CURRENT YEAR AND the most recent RELEASE year
FROM actor a 
INNER JOIN film_actor fa 
ON fa.actor_id = a.actor_id 
INNER JOIN film f 
ON f.film_id =fa.film_id
GROUP BY a.first_name, a.last_name
ORDER BY gap_since_last_movie DESC
limit (5);

-- V2
SELECT a.first_name, a.last_name,
    (SELECT MAX(f.release_year)                                -- Finding the most recent RELEASE year
     FROM film f 
     WHERE f.film_id IN (                                       -- Using IN for filtering for films where the actor has a ROLE, can have multiple values
					     SELECT fa.film_id             
					     FROM film_actor fa 
					     WHERE fa.actor_id = a.actor_id
					     )
    ) AS latest_movie_year,
    EXTRACT(YEAR FROM CURRENT_DATE) -                        ---- calculating the difference BETWEEN CURRENT YEAR AND the most recent RELEASE year
    (SELECT MAX(f.release_year) 
     FROM film f 
     WHERE f.film_id IN (                                     -- Using IN for filtering for films where the actor has a ROLE, can have multiple values
				         SELECT fa.film_id 
				         FROM film_actor fa 
				         WHERE fa.actor_id = a.actor_id
				     )
    ) AS gap_since_last_movie
FROM actor a 
ORDER BY gap_since_last_movie DESC
LIMIT 5;

