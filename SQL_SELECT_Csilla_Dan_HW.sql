
--PART 1--------------------------------------------------------------------------------------------------------------------------------
--1.	All animation movies released between 2017 and 2019 with rate more than 1, alphabetical
-- Interpetation: "rate more than 1" refers to the rental rate. 
-- The query aims to retrieve the titles of all animation films released between the years 2017 and 2019,
-- that have a rental rate greater than 1. The results are displayed in alphabetical order by the title.
-- The query pulls data from the film, film_category, and category tables, which contain information on movies, 
-- their categories, and rental attributes. By joining film_category with category, we ensure that only movies categorized as "Animation"
-- are included in the results, which also limits the dataset specifically to films in the Animation genre.
-- The query further restricts the results to animation movies released between 2017 and 2019 and also filters out films with a 
-- rental rate of 1 or lower, including only those that have a rental rate higher than 1. 

     
---V1 Using subqueries


SELECT f.title
FROM film f
WHERE f.release_year BETWEEN 2017 AND 2019  --- restricting movies released between 2017 and 2019
  AND f.rental_rate > 1 --- filtering OUT films with a rental rate of 1 or lower
  AND f.film_id IN (
				      SELECT fc.film_id
				      FROM film_category fc
				      WHERE fc.category_id = (
									          SELECT c.category_id
									          FROM category c
									          WHERE c.name = 'Animation'
									      ))								
ORDER BY f.title;

---V2 using joins
SELECT f.title
FROM film f
INNER JOIN film_category fc ON f.film_id = fc.film_id
INNER JOIN category c ON fc.category_id = c.category_id
WHERE c.name = 'Animation'
  AND f.release_year BETWEEN 2017 AND 2019
  AND f.rental_rate > 1
ORDER BY f.title;


--2.The revenue earned by each rental store since March 2017 (columns: address and address2 – as one column, revenue)
--Interpetation: Assuming revenue is realised on payment date, can be also on the date of the rental in some cases.
-- This query calculates and lists the total revenue generated by each store, identified by its location (city and country), 
-- for transactions made on or after March 1, 2017. The SELECT clause combines the city and country names into a single column (store), 
-- providing a readable identifier for each store location in the format "City, Country."
--- V1: Using joins
SELECT (c.city || ', '::text) || cy.country AS store,
    SUM(p.amount) AS revenue
FROM payment p
JOIN rental r ON p.rental_id = r.rental_id
JOIN inventory i ON r.inventory_id = i.inventory_id
JOIN store s ON i.store_id = s.store_id
JOIN address a ON s.address_id = a.address_id
JOIN city c ON a.city_id = c.city_id
JOIN country cy ON c.country_id = cy.country_id
WHERE payment_date >= '2017-03-01' -- assuming revenue is realised on payment date
GROUP BY cy.country, c.city, s.store_id
ORDER BY store
 
 ---V2 Using CTE

 WITH StoreRevenue AS (
						SELECT s.store_id,(c.city || ', ' || cy.country) AS store,
						        SUM(p.amount) AS revenue
						FROM payment p
						INNER JOIN rental r ON p.rental_id = r.rental_id
						INNER JOIN inventory i ON r.inventory_id = i.inventory_id
						INNER JOIN store s ON i.store_id = s.store_id
						INNER JOIN address a ON s.address_id = a.address_id
						INNER JOIN city c ON a.city_id = c.city_id
						INNER JOIN country cy ON c.country_id = cy.country_id
						WHERE p.payment_date >= '2017-03-01'  
						GROUP BY s.store_id, c.city, cy.country
						)

SELECT store, revenue
FROM StoreRevenue
ORDER BY store;

 
 
--3.Top-5 actors by number of movies (released since 2015) they took part in (columns: first_name, last_name, number_of_movies, 
--  sorted by number_of_movies in descending order)
--- V1 : Using subqueries
--- Interpetation : The primary goal is to identify the top five actors who have been actively participating in films since 2015.
---The data comes from two primary tables and one junction table:
----actor table: Contains details about each actor, such as their first and last names.
----film table: Contains information about films, including their release years.
----film_actor table: Acts as a junction table connecting actors with the films they have appeared in, 
----which allows us to track each actor’s filmography.
---By connecting these tables, we can extract relevant details about each actor and the films they have acted in.

--Note: We might want to  specify our ordering further (such as we should take account for the first name or last name in alphabetical 
--order)as there are more values with the same number of movies, exceeding the top 5.

-- V1: using subqueries
SELECT a.first_name, a.last_name, 
	(SELECT count(*) 
	FROM film_actor fa
	INNER JOIN film f ON fa.film_id = f.film_id
	WHERE fa.actor_id = a.actor_id AND f.release_year >= 2015 --Filtering based ON RELEASE YEAR INCLUDING 2015 onwards AND Connecting the OUTER AND INNER query based ON actor_id
	) AS number_of_movies
FROM  actor a                                                 
ORDER BY  number_of_movies DESC
LIMIT (5);
 
--- V2: using joins						 					 
SELECT a.first_name, a.last_name, count(*) as number_of_movies
FROM  actor a 
INNER JOIN film_actor fa 
ON a.actor_id = fa.actor_id 
INNER JOIN film f
ON fa.film_id=f.film_id 
WHERE f.release_year >= '2015'
GROUP BY a.first_name, a.last_name
ORDER BY number_of_movies DESC
LIMIT (5)
 
 
--4.Number of Drama, Travel, Documentary per year (columns: release_year, number_of_drama_movies, number_of_travel_movies, 
--  number_of_documentary_movies), sorted by release year in descending order. Dealing with NULL values is encouraged)
--Interpetation: Preparing a report on movie counts for Drama, Travel, and Documentary categories each year, 
--while handling cases with no data for a category in a given year by using COALESCE to display 0. In a sence, 
--we have to create subqueries for each category and then connect it to the main query.

--- V1 : Using CTE

WITH CategoryCounts AS (
    SELECT f.release_year,c."name",
        COUNT(f.film_id) AS movie_count
    FROM film f
    INNER JOIN film_category fc ON f.film_id = fc.film_id
    INNER JOIN category c ON fc.category_id = c.category_id
    WHERE c."name" IN ('Drama','Travel','Documentary')  -- IDs for Drama, Travel, and Documentary
    GROUP BY f.release_year, c.category_id
	)

SELECT cc.release_year,
    (SELECT COALESCE(SUM(movie_count), 0)    ---USING COALESCE TO display 0, IF there IS a NULL value
     FROM categorycounts cs
     WHERE cs."name" = 'Drama' AND release_year = cc.release_year) AS number_of_drama_movies,
    (SELECT COALESCE(SUM(movie_count), 0)    ---USING COALESCE TO display 0, IF there IS a NULL value
     FROM CategoryCounts cs
     WHERE cs."name" = 'Travel' AND release_year = cc.release_year) AS number_of_travel_movies,
    (SELECT COALESCE(SUM(movie_count), 0)    ---USING COALESCE TO display 0, IF there IS a NULL value
     FROM CategoryCounts cs
     WHERE cs."name" = 'Documentary' AND release_year = cc.release_year) AS number_of_documentary_movies
FROM CategoryCounts cc
GROUP BY cc.release_year
ORDER BY cc.release_year DESC;
   
   
---V2: Using subqueries
SELECT 
    f.release_year,
    -- Subquery for counting Drama movies
    (SELECT COALESCE(COUNT(f_d.film_id), 0)
     FROM film f_d
     INNER JOIN film_category fc_d ON f_d.film_id = fc_d.film_id
     INNER JOIN category c_d ON fc_d.category_id = c_d.category_id
     WHERE f_d.release_year = f.release_year AND c_d."name" = 'Drama'
    ) AS number_of_drama_movies,
    
    -- Subquery for counting Travel movies
    (SELECT COALESCE(COUNT(f_t.film_id), 0)
     FROM film f_t
     INNER JOIN film_category fc_t ON f_t.film_id = fc_t.film_id
     INNER JOIN category c_t ON fc_t.category_id = c_t.category_id
     WHERE f_t.release_year = f.release_year AND c_t."name" = 'Travel'
    ) AS number_of_travel_movies,
    
    -- Subquery for counting Documentary movies
    (SELECT COALESCE(COUNT(f_doc.film_id), 0)
     FROM film f_doc
     INNER JOIN film_category fc_doc ON f_doc.film_id = fc_doc.film_id
     INNER JOIN category c_doc ON fc_doc.category_id = c_doc.category_id
     WHERE f_doc.release_year = f.release_year AND c_doc."name" = 'Documentary'
    ) AS number_of_documentary_movies

FROM film f
GROUP BY f.release_year
ORDER BY f.release_year DESC;


--5.For each client, display a list of horrors that he had ever rented (in one column, separated by commas), 
--  and the amount of money that he paid for it.

-- Interpetation: The main query selects each customer’s customer_id, as well as their first_name and last_name concatenated 
-- as customer_name. Two subqueries needed for completing the task- one for the rented horror movies and one for the total amount paid.
-- The rented horror movies shows all horror movies rented by customers and subquery joins film, film_category, inventory, 
-- and rental tables to filter horror films rented by each customer, 
-- then uses STRING_AGG to concatenate all the horror movie titles the customer rented, separated by commas.
-- The total amount paid calculates the total amount each customer spent on horror rentals.
-- It joins payment, rental, inventory, and film_category tables to identify the horror movie rentals for each customer 
-- and sums the amount paid for those rentals.
-- The final report includes the customer’s ID, name, a comma-separated list of horror movies they rented (rented_horror_movies), 
-- and the total amount they spent on horror rentals (total_amount_paid).
  
---V1: Using CTE 
   
with Horrorrentals as            --Creating CTE for rentals, of which has a horror category
(select c.customer_id,c.first_name,c.last_name, f.title
AS horror_movies, p.amount
from customer c 
inner join rental r 
on c.customer_id =r.customer_id
inner join payment p 
on p.rental_id = r.rental_id
inner join inventory i 
on i.inventory_id = r.inventory_id 
inner join film_category fc 
on fc.film_id = i.film_id 
inner join film f 
on f.film_id = fc.film_id 
INNER JOIN category ca 
ON ca.category_id = fc.category_id
where ca."name" = 'Horror')       -- Filtering FOR Horror movies


select hr.customer_id,(hr.first_name|| ' '::text) || hr.last_name as customer_name,
    (select 
        STRING_AGG(hr2.horror_movies, ', ') --- USING string_agg TO concatenate string across ROWS.
     from HorrorRentals hr2
     where hr2.customer_id = hr.customer_id
    ) AS rented_horror_movies,  -- Concatenate movies in the subquery
    (select SUM(hr2.amount)
     from HorrorRentals hr2
     where hr2.customer_id = hr.customer_id
    ) AS total_amount_paid  -- Calculate the total amount paid in the subquery
from HorrorRentals hr
group by customer_name, hr.customer_id
order by customer_name;

---V2: Using subqueries ---
--The difference in behavior between the v1 and v2 queries lies in how each one processes and aggregates rental data. 
--The V1 query (using the CTE HorrorRentals) avoids NULL values because it explicitly filters the data within the CTE, 
--ensuring that only customers who have rented horror movies are included in the final results. 
--The V2 query includes all customers, regardless of whether they rented a horror movie or not, which results 
--in NULL values for customers with no relevant rentals or payments, therefore for handling these null values, 
--we have to change the WHERE clause in the outer query filtering based on the rows, in which rented_horror_movies or total_amount_paid 
--is NULL after computing their value.

   SELECT  
    c.customer_id,
    (c.first_name || ' ' || c.last_name) AS customer_name,
    
    -- Subquery to concatenate horror movies rented by the customer
    (SELECT STRING_AGG(f.title, ', ') 
     FROM film f
     INNER JOIN film_category fc 
     ON f.film_id = fc.film_id
     INNER JOIN inventory i 
     ON i.film_id = f.film_id
     INNER JOIN rental r 
     ON r.inventory_id = i.inventory_id
     INNER JOIN category ca
     ON ca.category_id = fc.category_id
     WHERE ca."name" = 'Horror' AND r.customer_id = c.customer_id  -- filtering FOR horror movies AND connecting INNER query TO OUTER query.
    ) AS rented_horror_movies,

    -- Subquery to calculate the total amount paid by the customer for horror rentals
    (SELECT SUM(p.amount)
     FROM payment p
     INNER JOIN rental r 
     ON p.rental_id = r.rental_id
     INNER JOIN inventory i 
     ON i.inventory_id = r.inventory_id
     INNER JOIN film_category fc 
     ON i.film_id = fc.film_id
     INNER JOIN category ca
     ON ca.category_id = fc.category_id
     WHERE ca."name" = 'Horror' AND r.customer_id = c.customer_id -- filtering FOR horror movies AND connecting INNER query TO OUTER query.
    ) AS total_amount_paid

FROM customer c
WHERE 
    -- Exclude customers with no rented horror movies or total amount paid
    (SELECT COUNT(*)
     FROM rental r
     INNER JOIN inventory i ON r.inventory_id = i.inventory_id
     INNER JOIN film_category fc ON i.film_id = fc.film_id
     INNER JOIN category ca ON ca.category_id = fc.category_id
     WHERE r.customer_id = c.customer_id AND ca."name" = 'Horror') > 0

ORDER BY customer_name;

-- PART 2------------------------------------------------------------------------------------------------------------------------------------
-- 6. Which three employees generated the most revenue in 2017? They should be awarded a bonus for their outstanding performance. 
--Assumptions: 
--staff could work in several stores in a year, please indicate which store the staff worked in (the last one);
--if staff processed the payment then he works in the same store; 
--take into account only payment_date

-- Interpetation: We do not want to filter the data by stores the staff worked in, only showing the latest stores they worked in 2017
-- and the total revenue the each staff generated in 2017. In case we would want to filter based on the latest store the staff worked in, 
-- we would extend the where caluse similarly to the subquery in the select main query.

--- Hanna Carry, Hanna Rainbow and Peter Lockyard  generated the most revenue in 2017.

---V1:

SELECT p.staff_id, s.first_name, s.last_name, 
    sum(p.amount) AS generated_revenue,
    (SELECT  s2.store_id
	FROM staff s2 
	INNER JOIN payment p2 
	ON p2.staff_id = s2.staff_id
	WHERE s2.staff_id = p.staff_id               -- Need TO JOIN INNER query TO main query
	AND EXTRACT(YEAR FROM p2.payment_date) = 2017 -- Filtering the payment date for 2017
	ORDER BY p2.payment_date DESC
	Limit(1)                                      -- Finding the latest store
	) AS last_store_id					
FROM payment p
INNER JOIN staff s 
ON s.staff_id = p.staff_id 
WHERE EXTRACT(YEAR FROM p.payment_date) = 2017   -- Filtering the payment date for 2017
GROUP BY p.staff_id, s.first_name, s.last_name
ORDER BY generated_revenue DESC
LIMIT (3) ---top 3 employee

---V2:

WITH StaffRevenue AS (
    SELECT p.staff_id, s.first_name, s.last_name,
        SUM(p.amount) AS generated_revenue
    FROM payment p
    INNER JOIN staff s 
    ON s.staff_id = p.staff_id
    WHERE EXTRACT(YEAR FROM p.payment_date) = 2017  -- Filtering the payment date for 2017
    GROUP BY p.staff_id, s.first_name, s.last_name
	)

SELECT sr.staff_id, sr.first_name, sr.last_name, sr.generated_revenue,
    -- CTE to find the last store where the staff worked
    (SELECT s.store_id
     FROM staff s 
     INNER JOIN payment p2 
     ON p2.staff_id = s.staff_id
     WHERE EXTRACT(YEAR FROM p2.payment_date) = 2017
     AND s.staff_id = sr.staff_id
     ORDER BY p2.payment_date DESC
     LIMIT 1
    ) AS last_store_id
FROM StaffRevenue sr
ORDER BY sr.generated_revenue DESC
LIMIT 3;



--7. Which 5 movies were rented more than others (number of rentals), and what's the expected age of the audience for these movies? 
--To determine expected age please use 'Motion Picture Association film rating system

--Interpetation:The query retrieves the titles of films along with the count of their rentals and the expected audience age based
-- on their Motion Picture Association film rating system ratings. The rental counts are calculated using subqueries to look up 
-- the inventory and rental records, ensuring that no ungrouped columns from the outer query are improperly referenced.
-- The result is ordered by the number of rentals in descending order, limited to the top five films.

-- Note: We ight want to specify our ordering further (such as we should take account title in alphabetical order or expected audinence age) 
-- as there are more values with the same number of rentals, exceeding the top 5.

---V1
SELECT f.title, count(r.rental_id) AS number_of_rentals,
CASE f.rating                                            -- USING CASE ..WHEN FOR applying different expressions or values based on specific conditions
        WHEN 'G' THEN 'All ages'
        WHEN 'PG' THEN '10+'
        WHEN 'PG-13' THEN '13+'
        WHEN 'R' THEN '17+'
        WHEN 'NC-17' THEN '18+'
        ELSE 'Unknown age rating'
        END AS expected_audience_age
FROM rental r
INNER JOIN inventory i 
ON i.inventory_id = r.inventory_id 
INNER JOIN film f 
ON f.film_id = i.film_id 
GROUP BY f.title, f.rating 
ORDER BY number_of_rentals DESC
LIMIT(5)

---V2: Using CTE, which calculates the number of rentals

WITH RentalCounts AS (
    SELECT 
        f.title,
        COUNT(r.rental_id) AS number_of_rentals,
        f.rating
    FROM 
        rental r
    INNER JOIN 
        inventory i ON i.inventory_id = r.inventory_id 
    INNER JOIN 
        film f ON f.film_id = i.film_id 
    GROUP BY 
        f.title, f.rating
)

SELECT 
    rc.title,
    rc.number_of_rentals,
    CASE rc.rating
        WHEN 'G' THEN 'All ages'
        WHEN 'PG' THEN '10+'
        WHEN 'PG-13' THEN '13+'
        WHEN 'R' THEN '17+'
        WHEN 'NC-17' THEN '18+'
        ELSE 'Unknown age rating'
    END AS expected_audience_age
FROM 
    RentalCounts rc
ORDER BY 
    rc.number_of_rentals DESC
LIMIT 5;


   
--Part 3. Which actors/actresses didn't act for a longer period of time than the others? 
--The task can be interpreted in various ways, and here are a few options:
--V1: gap between the latest release_year and current year per each actor;
--V2: gaps between sequential films per each actor;
--It would be plus if you could provide a solution for each interpretation

-- Selected the V1 interpetation of the task.: 
-- The query retrieves a list of the top five actors who have had the longest gaps since their most recent movie release. 
-- For each actor, it provides their ID, first name, last name, the release year of their latest movie, 
-- and the number of years since that release.

SELECT a.actor_id, a.first_name, a.last_name,
 MAX(f.release_year) AS latest_movie_year,
 EXTRACT (year FROM current_date) - MAX(f.release_year) AS gap_since_last_movie	
FROM actor a 
INNER JOIN film_actor fa 
ON fa.actor_id = a.actor_id 
INNER JOIN film f 
ON f.film_id =fa.film_id
GROUP BY a.actor_id, a.first_name, a.last_name
ORDER BY gap_since_last_movie DESC, a.actor_id 
limit (5)

--- V2
SELECT a.actor_id, a.first_name, a.last_name,
    (SELECT MAX(f.release_year) 
     FROM film f 
     WHERE f.film_id IN (
					     SELECT fa.film_id 
					     FROM film_actor fa 
					     WHERE fa.actor_id = a.actor_id
					     )
    ) AS latest_movie_year,
    EXTRACT(YEAR FROM CURRENT_DATE) - 
    (SELECT MAX(f.release_year) 
     FROM film f 
     WHERE f.film_id IN (
				         SELECT fa.film_id 
				         FROM film_actor fa 
				         WHERE fa.actor_id = a.actor_id
				     )
    ) AS gap_since_last_movie
FROM 
    actor a 
ORDER BY 
    gap_since_last_movie DESC, a.actor_id
LIMIT 5;


   
